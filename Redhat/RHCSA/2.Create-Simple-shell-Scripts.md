
# 0) Mental model

A shell script is just a text file the shell can execute line by line. For RHCSA you will use Bash.

* Interpreter line
  First line tells Linux which program runs the file.

  ```bash
  #!/usr/bin/env bash
  ```
* Make it executable

  ```bash
  chmod +x myscript.sh
  ./myscript.sh
  ```
* Run without exec bit

  ```bash
  bash myscript.sh
  ```

Opinion: stick to Bash, avoid fancy features you cannot explain.

---

# 1) Script skeleton you can reuse

```bash
#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'
# set -e   exit on error
# set -u   error on undefined variable
# set -o pipefail  fail a pipeline if any part fails

log(){ printf '%s %s\n' "$(date +%F_%T)" "$*"; }
die(){ printf 'ERROR: %s\n' "$*" >&2; exit 1; }

# Example main
main(){
  log "Hello from script"
}
main "$@"
```

On exam boxes you can drop `set -euo pipefail` if it gets in your way. It saves you from silent failures, but it is stricter.

---

# 2) Variables, quoting, and substitution

* Assign without spaces
  `NAME="Saria"`
* Expand with quotes
  `echo "User is $NAME"`
* Command substitution

  ```bash
  TODAY="$(date +%F)"
  HOSTS="$(wc -l < /etc/hosts)"
  ```
* Arithmetic

  ```bash
  n=$((3 + 2))
  ```

Golden rule: quote variables unless you want word splitting. Use `"${var}"`.

---

# 3) Script inputs: `$1`, `$2`, `$@`, `$#`, `shift`

```bash
#!/usr/bin/env bash
file="${1:-/etc/hosts}"   # default value if not given
echo "Script name: $0"
echo "First arg:  $1"
echo "Arg count:  $#"
for arg in "$@"; do echo "arg: $arg"; done
shift   # drops $1, now $2 becomes $1
```

* `$@` is each argument as a separate word, always quote it
* `$*` is one string with all args joined by IFS

---

# 4) Conditionally execute code: `if`, `test`, `[ ]`, `[[ ]]`, `(( ))`

## File tests

```bash
file="/etc/ssh/sshd_config"
if [ -f "$file" ]; then
  echo "File exists and is a regular file"
fi
```

Common tests:

* `-e` exists
* `-f` regular file
* `-d` directory
* `-r` readable
* `-w` writable
* `-x` executable
* `-s` size > 0

## Strings and numbers

```bash
s="hi"
[ -n "$s" ]           # non empty
[ -z "$s" ]           # empty
[ "$a" = "$b" ]       # string equal
[ "$a" != "$b" ]      # not equal

[ "$x" -eq 5 ]        # numeric equal
[ "$x" -gt 3 ]        # greater than
```

## `[[ .. ]]` for patterns

```bash
read ans
if [[ "$ans" == y* ]]; then echo "yes"; fi
if [[ "$name" =~ ^u[0-9]{2}$ ]]; then echo "user pattern"; fi
```

## Arithmetic test with `(( ))`

```bash
x=7
if (( x % 2 == 1 )); then echo "odd"; fi
```

## `if elif else` and command success

```bash
if systemctl is-active --quiet sshd; then
  echo "sshd running"
elif systemctl is-enabled --quiet sshd; then
  echo "enabled but not running"
else
  echo "not enabled"
fi
```

Short form with `&&` and `||`:

```bash
mkdir -p /tmp/lab && echo "ok" || echo "failed"
```

---

# 5) Looping constructs

## `for` over a list or glob

```bash
for f in /etc/*.conf; do
  echo "conf: $f"
done
```

## `for` over arguments

```bash
for user in "$@"; do
  id "$user" || echo "no such user: $user"
done
```

## `while` read from a file or pipeline

```bash
# Robust line reader, -r avoids backslash escapes
while IFS= read -r line; do
  printf 'line: %s\n' "$line"
done < /etc/passwd
```

## `until` loop

```bash
count=0
until (( count >= 3 )); do
  echo "try $count"
  ((count++))
done
```

---

# 6) Process output of commands inside scripts

Use command substitution and loops.

```bash
# Count active services
active=$(systemctl list-units --type=service --state=running --no-legend | wc -l)
echo "running services: $active"

# Iterate over package names found by dnf
while IFS= read -r pkg; do
  echo "found: $pkg"
done < <(dnf list --installed | awk 'NR>1{print $1}')
```

Note the `< <(command)` form. That is process substitution. You can also use a plain pipeline into `while read -r`.

---

# 7) Functions, returns, exit codes

```bash
check_port(){
  local port="$1"
  ss -lnt | awk -v p=":$port" '$4 ~ p {found=1} END{exit found?0:1}'
}

if check_port 22; then
  echo "port 22 open"
else
  echo "port 22 closed"
fi
```

* `exit N` leaves the script with code N
* `return N` leaves the function with code N

---

# 8) Case statements for clean branching

```bash
read -r answer
case "$answer" in
  y|Y|yes|YES) echo "yes" ;;
  n|N|no|NO)   echo "no" ;;
  *)           echo "please answer yes or no" ;;
esac
```

---

# 9) Logging, temp files, traps

```bash
tmp=$(mktemp -t myscript.XXXXXX)
cleanup(){ rm -f "$tmp"; }
trap cleanup EXIT

echo "work" > "$tmp"
```

`trap` protects you from messy leftovers.

---

# 10) Five tiny scripts you should be able to write blind

## check-user.sh

```bash
#!/usr/bin/env bash
set -euo pipefail
user="${1:-}"
[ -z "$user" ] && { echo "usage: $0 <username>"; exit 2; }
if id "$user" &>/dev/null; then
  echo "User $user exists"
  id "$user"
else
  echo "User $user does not exist"
fi
```

## rotate-logs.sh

```bash
#!/usr/bin/env bash
set -euo pipefail
src="${1:-/var/log}"
dest="${2:-/tmp/logs_$(date +%F).tgz}"
sudo tar -czf "$dest" "$src"
echo "Archive at $dest"
```

## ensure-service.sh

```bash
#!/usr/bin/env bash
set -euo pipefail
svc="${1:-sshd}"
if systemctl is-active --quiet "$svc"; then
  echo "$svc already running"
else
  sudo systemctl enable --now "$svc"
  echo "$svc started and enabled"
fi
```

## add-bulk-users.sh

```bash
#!/usr/bin/env bash
set -euo pipefail
file="${1:-users.txt}"
[ -f "$file" ] || { echo "no such file: $file"; exit 2; }
while IFS=: read -r u comment; do
  [ -z "$u" ] && continue
  sudo useradd -m -c "${comment:-}" "$u" 2>/dev/null || true
done < "$file"
```

## restrict-http.sh

```bash
#!/usr/bin/env bash
set -euo pipefail
net="${1:-192.0.2.0/24}"
sudo firewall-cmd --permanent --zone=public \
  --add-rich-rule="rule family='ipv4' source address='${net}' service name='http' accept"
sudo firewall-cmd --permanent --zone=public \
  --add-rich-rule="rule family='ipv4' service name='http' drop"
sudo firewall-cmd --reload
```

These mirror tasks you actually do on RHCSA.

---

# 11) Common pitfalls and how to avoid them

* Forgetting the shebang. The wrong shell runs, odd bugs follow.
* Not quoting variables. Paths with spaces explode. Quote `"${var}"`.
* Using `for line in $(cat file)` which breaks on spaces. Use `while IFS= read -r`.
* Parsing human friendly output when a command has a machine friendly mode. For example, `systemctl … --no-legend --plain`.
* Testing numeric values with `[` and `=` instead of `-eq`. Strings use `=`, numbers use `-eq`.

Tiny joke break. Bash is like Vim. Painful for one day, useful for the rest of your career.

---

# 12) Mini reference for tests and loops

## File tests

`-e -f -d -r -w -x -s -h`

```bash
[ -d /etc ] && echo "dir"
```

## String and number tests

```bash
[ -n "$s" ] [ -z "$s" ] [ "$a" = "$b" ] [ "$n" -gt 10 ]
```

## `[[ .. ]]` patterns and regex

```bash
[[ "$f" == *.conf ]] || echo "not a conf"
[[ "$user" =~ ^u[0-9]{2}$ ]] && echo "ok"
```

## Loops

```bash
for f in /etc/*.conf; do :; done
while read -r line; do :; done < file
until ping -c1 host &>/dev/null; do sleep 1; done
```

---

# 13) Labs first, solutions after

Do not peek. Work in `/tmp/scripting`.

## Setup

```bash
mkdir -p /tmp/scripting && cd /tmp/scripting
```

### A. Conditionals and tests

1. Write `filecheck.sh` that takes a path `$1`. If it is a directory, print `DIR`. If it is a file and size > 0, print `FILE`. Else print `OTHER`. Exit 0 in all cases.
2. Write `usergate.sh` that returns exit 0 if user `$1` exists, exit 2 otherwise, and prints a helpful message.

### B. Loops

3. Write `count-confs.sh` that prints the count of `.conf` files under `/etc` using a `for` loop and a counter.
4. Write `list-users.sh` that reads `/etc/passwd` and prints usernames and shells, one per line, using `while IFS=: read -r user _ _ _ _ _ shell`.

### C. Process script inputs

5. Write `greeter.sh` that prints `Hello <name>` for every argument given, or `Hello world` if none are given. Use `$#`, `$@`, and `shift`.
6. Write `sum.sh` that adds any number of numeric arguments and prints the total.

### D. Process command output

7. Write `service-report.sh` that prints the number of running services, then lists the first five names only. Use `systemctl list-units --type=service --state=running --no-legend`.
8. Write `largest-logs.sh` that lists the top 5 largest files in `/var/log` with size and path, sorted descending, using `du -ab` or `find -type f -printf`.

### E. Case and functions

9. Write `toggle-service.sh <svc> <start|stop|status>` that uses a `case` statement and a helper function `ensure_enabled` that enables a service when starting.
10. Write `safe-tmp.sh` that creates a temp file with `mktemp`, writes a line to it, prints the path, and removes it on exit with `trap`.

---

# SOLUTIONS

### A1 filecheck.sh

```bash
#!/usr/bin/env bash
set -euo pipefail
p="${1:-}"
[ -z "$p" ] && { echo "usage: $0 <path>"; exit 2; }
if [ -d "$p" ]; then
  echo "DIR"
elif [ -f "$p" ] && [ -s "$p" ]; then
  echo "FILE"
else
  echo "OTHER"
fi
```

### A2 usergate.sh

```bash
#!/usr/bin/env bash
set -euo pipefail
u="${1:-}"
[ -z "$u" ] && { echo "usage: $0 <user>"; exit 2; }
if id "$u" &>/dev/null; then
  echo "User $u exists"
  exit 0
else
  echo "User $u not found"
  exit 2
fi
```

### B3 count-confs.sh

```bash
#!/usr/bin/env bash
set -euo pipefail
count=0
for f in /etc/*.conf /etc/**/*.conf; do
  [ -e "$f" ] || continue
  ((count++))
done
echo "$count"
```

### B4 list-users.sh

```bash
#!/usr/bin/env bash
set -euo pipefail
while IFS=: read -r user _ _ _ _ _ shell; do
  printf '%s %s\n' "$user" "$shell"
done < /etc/passwd
```

### C5 greeter.sh

```bash
#!/usr/bin/env bash
set -euo pipefail
if [ "$#" -eq 0 ]; then
  echo "Hello world"
else
  for name in "$@"; do
    echo "Hello $name"
  done
fi
```

### C6 sum.sh

```bash
#!/usr/bin/env bash
set -euo pipefail
total=0
for n in "$@"; do
  [ -n "$n" ] || continue
  # optional numeric guard
  if ! [[ "$n" =~ ^-?[0-9]+$ ]]; then
    echo "skip non number: $n" >&2
    continue
  fi
  total=$(( total + n ))
done
echo "$total"
```

### D7 service-report.sh

```bash
#!/usr/bin/env bash
set -euo pipefail
mapfile -t svcs < <(systemctl list-units --type=service --state=running --no-legend | awk '{print $1}')
echo "running: ${#svcs[@]}"
printf '%s\n' "${svcs[@]:0:5}"
```

### D8 largest-logs.sh

```bash
#!/usr/bin/env bash
set -euo pipefail
# If du -ab not available, use find with -printf
find /var/log -type f -printf '%s %p\n' 2>/dev/null | sort -nr | head -n 5
```

### E9 toggle-service.sh

```bash
#!/usr/bin/env bash
set -euo pipefail
svc="${1:-}"; action="${2:-status}"
[ -z "$svc" ] && { echo "usage: $0 <svc> <start|stop|status>"; exit 2; }

ensure_enabled(){ systemctl is-enabled --quiet "$svc" || sudo systemctl enable "$svc"; }

case "$action" in
  start) ensure_enabled; sudo systemctl start "$svc"; systemctl status "$svc" --no-pager ;;
  stop)  sudo systemctl stop "$svc"; systemctl is-active --quiet "$svc" || echo "stopped" ;;
  status|*) systemctl status "$svc" --no-pager ;;
esac
```

### E10 safe-tmp.sh

```bash
#!/usr/bin/env bash
set -euo pipefail
tmp=$(mktemp -t safe.XXXXXX)
cleanup(){ rm -f "$tmp"; }
trap cleanup EXIT
echo "hello tmp" > "$tmp"
echo "Created: $tmp"
```

---

## One page cheat sheet

* Shebang and run
  `#!/usr/bin/env bash` then `chmod +x script.sh` and `./script.sh`
* Inputs
  `$0 $1 $2` • `$#` count • `$@` all args • `shift`
  Defaults with `"${1:-default}"`
* Tests
  Files `-f -d -e -r -w -x -s`
  Strings `-n -z` and `=` or `!=`
  Numbers `-eq -ne -gt -lt`
  `[[ pattern ]]` and `(( arithmetic ))`
* Conditionals
  `if elif else fi` • `case ... esac` • `cmd && ok || fail`
* Loops
  `for x in list; do ...; done`
  `while IFS= read -r line; do ...; done < file`
  `until condition; do ...; done`
* Process output
  `var="$(command)"` • `while ... < <(command)`
* Safety
  `set -euo pipefail` • quote vars • `trap 'rm -f "$tmp"' EXIT`
* Useful utilities
  `awk sed grep cut sort uniq wc xargs` for simple parsing

